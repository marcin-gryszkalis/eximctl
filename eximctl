#!/usr/bin/perl -w
# https://github.com/marcin-gryszkalis/eximctl

# info:
# http://www.exim.org/exim-html-current/doc/html/spec_html/ch-the_exim_command_line.html
# http://www.exim.org/exim-html-current/doc/html/spec_html/ch-exim_utilities.html
# http://bradthemad.org/tech/notes/exim_cheatsheet.php
# http://www.gnode.net/exim-cheatsheet/

use strict;
use warnings;
use utf8;
use Data::Dumper;
use POSIX qw(strftime);
use FindBin qw($RealBin);

my $REV = "0.4";

my $cfg = {
# defaults:
'eximproc' => 'exim-4',
'user' => 'mailnull',
'fadeout_time' => 30,  # time for stopping without killing -9
'logdir' => '/var/log/exim',
'mainlog' => 'exim-main-%Y%m%d.log',
'exitop' => '~/git/exitop/exitop'
};

my @conffiles = qw#/etc/eximctl.conf /usr/local/etc/eximctl.conf $RealBin/eximctl.conf#;
for my $cf (@conffiles)
{
    next unless -f $cf;
    open(my $cff, $cf) or die "cannot read config ($cf): $!";
    while (<$cff>)
    {
        next unless /^\s*(\S+?)\s*=\s*(.*?)\s*$/;
        $cfg->{$1} = $2;
    }
}

my $killall = " -u '$cfg->{user}' -m '$cfg->{eximproc}' ";
my $mainlog =  strftime("$cfg->{logdir}/$cfg->{mainlog}", localtime(time));

my $remsgid = '[a-zA-Z0-9]{6}-[a-zA-Z0-9]{6}-[a-zA-Z0-9]{2}';

sub help
{
print <<EOH
eximctl $REV <mg\@fork.pl>
   start                  -- start exim via service
   stop                   -- stop exim via service and SIGKILL
   restart                -- stop + start
   status                 -- status
   what                   -- full status
   kill                   -- kill all exim process
   top                    -- exitop (using exim main log)

   config                 -- show config
   syntax                 -- test configuration syntax
   reload                 -- reload config with SIGHUP
   version                -- show exim version

   mailq                  -- show the queue
   mailqq                 -- show the queue (brief format)
   queue                  -- show the queue, mailq alias
   qsize                  -- show queue size
   qstats                 -- queue statistics
   qgrep <msg spec>       -- grep queue (brief format)

   flush <msg spec>       -- flush queue
   flushall               -- flush all (including frozen, exim -qff mode)

   log <msg spec>         -- show log for message
   head <msg spec>        -- show message header
   body <msg spec>        -- show message body
   contents <msg spec>    -- show complete contents (header+body) of message

   delete <msg spec>      -- delete message from queue (no error sent)
   fail <msg spec>        -- fail message (bounce)
   freeze <msg spec>      -- freeze message
   thaw <msg spec>        -- thaw (unfreeze) message

   routing email          -- view routing for email

    <msg spec> -- specification for message:
     - msg id - message id, formatted as xxxxxx-xxxxxx-xx
     - [from|to] regexp - regexp to be matched against sender (from, the default) or recipient (to)
     - use explicit regexp to match all messages (eg. single dot would match any message)

EOH
;
    exit;
}

my $details;
sub queue_by_message_spec
{
    my $spec = shift @ARGV;
    my $subj = 'from';
    my @ret;

    help() unless defined $spec;

    if ($spec =~ /^$remsgid/) # msg id
    {
        push(@ret, $spec);
    }
    else
    {
        if ($spec =~ /^(from|to)$/i)
        {
            $subj = $1;
            $spec = shift @ARGV;
        }

        my $exqopt = '-b';

        if ($spec eq 'from') 
        {
            $exqopt = "-b -f '$subj'" 
        }
        else # to
        {
            $exqopt = "-b -t '$subj'" 
        }

        open(my $m, "exiqgrep $exqopt|");
        while (<$m>)
        {
            
            if (/^($remsgid)\s+From:\s+(<(\S+)>)\s+To:\s+(\S+)/)
            {
                my $mid = $1;
                my $mfrom = $2;
                my $mto = $3;

                push(@ret, $mid);
                $details->{$mid} = "$mid $mfrom -> $mto";
            }
            
        }

    }

    return \@ret;
}

sub process_queue_with_option 
{
    my $opt = shift;
    my $q = queue_by_message_spec();
    for my $mid (@$q)
    {
        print $details->{$mid} // $mid, "\n";
        print `exim $opt '$mid'`;
    }
}

sub is_alive
{
    my $p = `killall -SIGHUP -s $killall 2>/dev/null |wc -l`;
    chomp $p;
    $p =~ s/\D//g;
    return $p;
}

sub x_start
{
    print `service exim start`;
}

sub x_stop
{
    print `service exim stop`;
    my $p = is_alive();
    my $t = 0;
    while ($p > 0 && $t < $cfg->{fadeout_time})
    {
        sleep(1);
        print "$p...";
        $t++;
        $p = is_alive();
    }

    if ($p)
    {
        print "terminating...";
        x_kill();
    }
    else
    {
        print "stopped\n";
    }
}

sub x_restart
{
    x_stop();
    x_start();
}

sub x_status
{
    print `service exim status`;
}

sub x_what
{
    print `exiwhat`;
}


sub x_kill
{    
    my $t = 0;
    my $p = is_alive();
    while ($p > 0 && $t < $cfg->{fadeout_time})
    {
        sleep(1);
        print "$p...";
        `killall -SIGTERM $killall`;
        $t++;
        $p = is_alive();
    }

    if ($p)
    {
        print "killing survivors...";
        `killall -SIGKILL $killall`;
        sleep(3);
        if (is_alive())
        {
            print "they're still alive\n";
        }   
        else
        {
            print "done\n";
        }
    }
    else
    {
        print "stopped\n";
    }
}

sub x_top
{
    exec "$cfg->{exitop} $mainlog";
}

sub x_config
{
    print `exim -bP`;
}
 
sub x_syntax
{
    my $a = `exim -bV`;
    $a =~ m{(.*)Exim version};
    $a = $1;
    $a =~ s/\s+//g;
    $a = "Syntax OK" if $a eq '';
    print "$a\n";
}

sub x_reload
{
    `killall -SIGHUP -v $killall`;
    print "reloaded...\n";
}

sub x_version
{
    print `exim -bV`;
}
 
sub x_mailq
{
    print `exim -bp`;
}
 
sub x_mailqq
{
    print `exiqgrep -b`;
}

sub x_queue
{
    return x_mailq();
}

sub x_qsize
{
    print `exim -bpc`;
}

sub x_qstats
{
    print `exim -bp | exiqsumm`;
}

sub x_qgrep
{
    my $r = shift;
    print `exiqgrep -f '$r' -b`;
}

sub x_flush
{
    process_queue_with_option('-M');
}
 
sub x_flushall
{
    print `exim -qff`;
}  

sub x_log
{
    process_queue_with_option('-Mvl');
}  
 
sub x_head
{
    process_queue_with_option('-Mvh');
}  
 
sub x_body
{
    process_queue_with_option('-Mvb');
}  

sub x_contents
{
    process_queue_with_option('-Mvc');
}  


sub x_delete
{
    process_queue_with_option('-Mrm');
}  
 
sub x_fail
{
    process_queue_with_option('-Mg');
}  
 
sub x_freeze
{
    process_queue_with_option('-Mf');
}  
 
sub x_thaw
{
    process_queue_with_option('-Mt');
}  
 
sub x_routing
{
    my $m = shift;
    help() unless $m;
    print `exim -bt '$m'`;
}  

help() if ($#ARGV < 0);
my $command = shift;

my $ev = eval "x_$command()";
help() unless defined $ev;


